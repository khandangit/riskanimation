<!DOCTYPE html>
<html>
<head>
  <title>Interactive Pathway Animation (p5.js)</title>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <!-- CCapture for recording GIF/WebM -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ccapture.js/1.1.0/CCapture.all.min.js"></script>
  <style>
    :root { --ui-gap: 10px; }
    body { margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; font-family: system-ui, Arial, sans-serif; background: #f6f7f9; }
    #ui { display: grid; grid-template-columns: repeat(11, auto); gap: var(--ui-gap); align-items: center; padding: 12px; background: #fff; border-radius: 10px; box-shadow: 0 4px 14px rgba(0,0,0,0.08); margin: 12px; }
    #ui > * { margin: 0; }
    label { font-size: 12px; color: #333; }
    button { padding: 6px 10px; border-radius: 8px; border: 1px solid #ddd; background: #fafafa; cursor: pointer; }
    button:hover { background: #f0f0f0; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    canvas { display: block; background: #fff; border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,0.12); }
    @media (max-width: 1100px) { #ui { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <div id="ui">
    <label>Shape</label>
    <select id="shapeSel" title="Pick a marker shape">
      <option>Bug</option>
      <option>Virus</option>
      <option>Spore</option>
      <option>Droplet</option>
      <option>Mite</option>
    </select>

    <label>Speed (slower â†’ faster)</label>
    <input id="speed" type="range" min="40" max="200" step="5" value="120">

    <label>Min size</label>
    <input id="sizeMin" type="range" min="6" max="40" step="1" value="10">

    <label>Max size</label>
    <input id="sizeMax" type="range" min="30" max="80" step="1" value="50">

    <button id="pauseBtn">Pause</button>
    <button id="restartBtn">Restart</button>
    <button id="saveBtn">Save PNG</button>

    <button id="recGifBtn" title="Record as animated GIF">Record GIF</button>
    <button id="recWebmBtn" title="Record as WebM video">Record WebM</button>
    <button id="stopSaveBtn" disabled>Stop &amp; Save</button>
  </div>

  <script>
    // --- Layout constants
    const CAN_W = 1000, CAN_H = 420;
    const X_START = 150, X_END = 550, X_CENTER = (X_START + X_END) / 2;
    const ROW_Y = [80, 160, 240, 320];
    const LEFT_TEXT_X = 130;   // left labels close to the line start
    const RIGHT_TEXT_X = 570;  // right labels just after line end

    // Colours per pathway (nice palette)
    const PATH_COLOURS = [
      { fill: [52, 120, 246], stroke: [30, 80, 210] },   // Pathway 1 - blue
      { fill: [0, 168, 125],  stroke: [0, 120, 88] },    // Pathway 2 - green
      { fill: [242, 153, 74], stroke: [215, 112, 39] },  // Pathway 3 - orange
      { fill: [235, 87, 87],  stroke: [200, 50, 50] }    // Pathway 4 - red
    ];

    // DOM refs
    let shapeSel, speedSlider, sizeMinSlider, sizeMaxSlider, pauseBtn, restartBtn, saveBtn;
    let recGifBtn, recWebmBtn, stopSaveBtn;

    // Animation state
    let paused = false;
    let t = 0;            // logical time 0..6
    let finished = false; // reached the end once (no loop)

    // Explosions for pathways with High Impact at end (3 & 4)
    let explosions = []; // array of particle arrays

    // Recording state
    let capturer = null;
    let capturing = false;
    let canvasEl = null; // p5 canvas HTML element
    const GIF_WORKERS_PATH = 'https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/'; // must end with a trailing slash

    function setup() {
      const cnv = createCanvas(CAN_W, CAN_H);
      cnv.parent(document.body);
      canvasEl = cnv.canvas;
      noStroke();
      textSize(12);
      textAlign(CENTER);

      // Hook up DOM controls
      shapeSel      = document.getElementById('shapeSel');
      speedSlider   = document.getElementById('speed');
      sizeMinSlider = document.getElementById('sizeMin');
      sizeMaxSlider = document.getElementById('sizeMax');
      pauseBtn      = document.getElementById('pauseBtn');
      restartBtn    = document.getElementById('restartBtn');
      saveBtn       = document.getElementById('saveBtn');
      recGifBtn     = document.getElementById('recGifBtn');
      recWebmBtn    = document.getElementById('recWebmBtn');
      stopSaveBtn   = document.getElementById('stopSaveBtn');

      pauseBtn.onclick = () => {
        if (finished) return; // don't toggle after finish; use Restart
        paused = !paused;
        pauseBtn.textContent = paused ? 'Play' : 'Pause';
      };

      restartBtn.onclick = () => restartAnimation();
      saveBtn.onclick = () => saveCanvas('risk_pathways', 'png');

      recGifBtn.onclick = () => startRecording('gif');
      recWebmBtn.onclick = () => startRecording('webm');
      stopSaveBtn.onclick = () => stopAndSaveRecording();
    }

    function restartAnimation() {
      t = 0;
      paused = false;
      finished = false;
      explosions = [];
      pauseBtn.textContent = 'Pause';
      loop(); // ensure draw keeps running
    }

    function startRecording(format) {
      if (capturing) return; // already recording
      // Restart so we capture from the beginning
      restartAnimation();

      const fr = (format === 'gif') ? 20 : 30; // GIF a bit lower FPS to keep file size reasonable
      const commonOpts = { framerate: fr, verbose: true, name: `pathways_${format}` };

      if (format === 'gif') {
        capturer = new CCapture({
          format: 'gif',
          workersPath: GIF_WORKERS_PATH, // CCapture will append gif.worker.js
          ...commonOpts
        });
      } else {
        capturer = new CCapture({
          format: 'webm',
          quality: 100, // highest quality webm
          ...commonOpts
        });
      }

      capturing = true;
      updateRecordButtons();
      capturer.start();
    }

    function stopAndSaveRecording() {
      if (!capturing) return;
      capturer.stop();
      capturer.save();
      capturing = false;
      updateRecordButtons();
    }

    function updateRecordButtons() {
      recGifBtn.disabled = capturing;
      recWebmBtn.disabled = capturing;
      stopSaveBtn.disabled = !capturing;
    }

    function draw() {
      background(246);

      // Guides: the four paths
      stroke(200);
      for (let i = 0; i < ROW_Y.length; i++) {
        line(X_START, ROW_Y[i], X_END, ROW_Y[i]);
      }
      noStroke();

      // Titles
      fill(20);
      textAlign(CENTER);
      text('Pathway 1', X_CENTER, ROW_Y[0] - 30);
      text('Pathway 2', X_CENTER, ROW_Y[1] - 30);
      text('Pathway 3', X_CENTER, ROW_Y[2] - 30);
      text('Pathway 4', X_CENTER, ROW_Y[3] - 30);

      // Likelihood (left) & Impact (right)
      textAlign(RIGHT);
      text('High Likelihood', LEFT_TEXT_X, ROW_Y[0]);
      text('Low Likelihood',  LEFT_TEXT_X, ROW_Y[1]);
      text('Low Likelihood',  LEFT_TEXT_X, ROW_Y[2]);
      text('High Likelihood', LEFT_TEXT_X, ROW_Y[3]);

      textAlign(LEFT);
      text('Low Impact',  RIGHT_TEXT_X, ROW_Y[0]);
      text('Low Impact',  RIGHT_TEXT_X, ROW_Y[1]);
      text('High Impact', RIGHT_TEXT_X, ROW_Y[2]);
      text('High Impact', RIGHT_TEXT_X, ROW_Y[3]);

      // --- Animation timing (no loop: stop at t=6)
      const speedDiv = Number(speedSlider.value); // larger = slower
      if (!paused && !finished) {
        t += (1 / speedDiv) * 3; // tune multiplier for taste
        if (t >= 6) {
          t = 6;
          finished = true;
          // trigger explosions at end for pathways 3 & 4
          spawnExplosion(X_END, ROW_Y[2], PATH_COLOURS[2]);
          spawnExplosion(X_END, ROW_Y[3], PATH_COLOURS[3]);
        }
      }

      // Sizes from UI
      const S_MIN = Number(sizeMinSlider.value);
      const S_MAX = Number(sizeMaxSlider.value);

      // Position along path: hold at start until t>3, then move to end
      let xPos = (t <= 3) ? X_START : map(t, 3, 6, X_START, X_END);

      // Keep initial sizes reflecting likelihood; apply changes only during movement
      const p1Size = (t <= 3) ? S_MAX : map(t, 3, 6, S_MAX, S_MIN); // big then shrink
      const p2Size = S_MIN;                                         // always small
      const p3Size = (t <= 3) ? S_MIN : map(t, 3, 6, S_MIN, S_MAX); // small then grow
      const p4Size = S_MAX;                                         // always big

      // Draw the moving markers per pathway (colourful)
      setColours(0); drawMarker(shapeSel.value, xPos, ROW_Y[0], p1Size);
      setColours(1); drawMarker(shapeSel.value, xPos, ROW_Y[1], p2Size);
      setColours(2); drawMarker(shapeSel.value, xPos, ROW_Y[2], p3Size);
      setColours(3); drawMarker(shapeSel.value, xPos, ROW_Y[3], p4Size);

      // If finished, keep markers at final state (visible alongside explosions)
      if (finished) {
        setColours(0); drawMarker(shapeSel.value, X_END, ROW_Y[0], S_MIN);
        setColours(1); drawMarker(shapeSel.value, X_END, ROW_Y[1], S_MIN);
        setColours(2); drawMarker(shapeSel.value, X_END, ROW_Y[2], S_MAX);
        setColours(3); drawMarker(shapeSel.value, X_END, ROW_Y[3], S_MAX);
      }

      // Explosions (animate even after finished)
      updateExplosions();

      // Capture frame if recording
      if (capturing) {
        capturer.capture(canvasEl);
      }

      // If finished and explosions burned out, stop draw() and auto-save recording
      if (finished && explosions.length === 0) {
        if (capturing) {
          stopAndSaveRecording();
        }
        noLoop(); // stop rendering to save CPU
      }
    }

    function setColours(i) {
      const c = PATH_COLOURS[i];
      fill(c.fill[0], c.fill[1], c.fill[2]);
      stroke(c.stroke[0], c.stroke[1], c.stroke[2]);
      strokeWeight(1.5);
    }

    // --- Marker drawing (pest/pathogen metaphors)
    function drawMarker(type, x, y, s) {
      push();
      switch (type) {
        case 'Bug':
          // Fly emoji ðŸª° for the bug shape (emoji itself provides colour)
          noStroke();
          textAlign(CENTER, CENTER);
          textSize(s * 1.2);
          text('ðŸª°', x, y + s * 0.05);
          break;

        case 'Virus':
          drawVirus(x, y, s); // uses current stroke/fill (colourful via setColours)
          break;

        case 'Spore':
          ellipse(x, y, s, s);
          noStroke();
          fill(255, 255, 255, 100);
          ellipse(x, y, s * 0.35, s * 0.35);
          break;

        case 'Droplet':
          drawDroplet(x, y, s);
          break;

        case 'Mite':
          drawMite(x, y, s);
          break;
      }
      pop();
    }

    function drawVirus(x, y, s) {
      push();
      ellipse(x, y, s, s); // core
      const n = 10;
      for (let i = 0; i < n; i++) {
        const a = TWO_PI * i / n;
        const ox = x + cos(a) * s * 0.45;
        const oy = y + sin(a) * s * 0.45;
        line(x, y, ox, oy);
        ellipse(ox, oy, s * 0.15, s * 0.15);
      }
      pop();
    }

    function drawDroplet(x, y, s) {
      push();
      beginShape();
      vertex(x, y - s / 2);
      bezierVertex(x + s / 3, y - s / 4, x + s / 2, y, x, y + s / 2);
      bezierVertex(x - s / 2, y, x - s / 3, y - s / 4, x, y - s / 2);
      endShape(CLOSE);
      pop();
    }

    function drawMite(x, y, s) {
      push();
      beginShape();
      vertex(x, y - s * 0.5);
      vertex(x + s * 0.45, y + s * 0.4);
      vertex(x - s * 0.45, y + s * 0.4);
      endShape(CLOSE);
      for (let i = -1; i <= 1; i += 2) {
        line(x + i * s * 0.3, y - s * 0.1, x + i * s * 0.7, y - s * 0.35);
        line(x + i * s * 0.35, y + s * 0.05, x + i * s * 0.75, y + s * 0.05);
        line(x + i * s * 0.3, y + s * 0.2, x + i * s * 0.7, y + s * 0.4);
      }
      pop();
    }

    // --- Explosions (for High Impact endpoints)
    function spawnExplosion(x, y, colour) {
      const parts = [];
      const N = 60; // number of particles
      for (let i = 0; i < N; i++) {
        const ang = random(TWO_PI);
        const spd = random(1.5, 4.5);
        parts.push({
          x: x, y: y,
          vx: cos(ang) * spd,
          vy: sin(ang) * spd,
          life: 0,
          maxLife: random(40, 70),
          col: colour
        });
      }
      explosions.push(parts);
    }

    function updateExplosions() {
      for (let g = explosions.length - 1; g >= 0; g--) {
        const parts = explosions[g];
        let alive = 0;
        for (let p of parts) {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.05; // gravity
          p.life++;
          const alpha = map(p.life, 0, p.maxLife, 255, 0);
          if (alpha > 0) {
            stroke(p.col.stroke[0], p.col.stroke[1], p.col.stroke[2], alpha);
            fill(p.col.fill[0], p.col.fill[1], p.col.fill[2], alpha);
            circle(p.x, p.y, 4);
            alive++;
          }
        }
        if (alive === 0) explosions.splice(g, 1);
      }
    }

    // Click canvas to quick toggle pause (while running)
    function mousePressed() {
      if (!finished && mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
        paused = !paused;
        pauseBtn.textContent = paused ? 'Play' : 'Pause';
      }
    }
  </script>
</body>
</html>
