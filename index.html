<!DOCTYPE html>
<html>
<head>
  <title>Interactive Pathway Animation (p5.js)</title>
  <meta charset="utf-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <style>
    :root { --ui-gap: 10px; }
    body { margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; font-family: system-ui, Arial, sans-serif; background: #f6f7f9; }
    #ui {
      display: grid;
      grid-template-columns: repeat(12, auto);
      gap: var(--ui-gap);
      align-items: center;
      padding: 12px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.08);
      margin: 12px;
    }
    #ui > * { margin: 0; }
    label { font-size: 12px; color: #333; }
    input[type="text"] { padding: 6px 8px; border: 1px solid #ddd; border-radius: 8px; }
    button { padding: 6px 10px; border-radius: 8px; border: 1px solid #ddd; background: #fafafa; cursor: pointer; }
    button:hover { background: #f0f0f0; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    #playBtn { background: #4caf50; color: white; }
    #playBtn:hover { background: #43a047; }
    #status { font-size: 12px; color: #444; padding: 4px 8px; background: #f3f6ff; border: 1px solid #d7e2ff; border-radius: 8px; }
    canvas { display: block; background: #fff; border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,0.12); }
    @media (max-width: 1200px) { #ui { grid-template-columns: 1fr 1fr; } }
  </style>
</head>
<body>
  <div id="ui">
    <label>Shape</label>
    <select id="shapeSel" title="Pick a marker shape">
      <option>Bug</option>
      <option>Virus</option>
      <option>Spore</option>
    </select>

    <label>Speed (faster â†’ slower)</label>
    <input id="speed" type="range" min="40" max="200" step="5" value="120">

    <label>Min size</label>
    <input id="sizeMin" type="range" min="6" max="40" step="1" value="10">

    <label>Max size</label>
    <input id="sizeMax" type="range" min="30" max="80" step="1" value="50">

    <button id="pauseBtn">Pause</button>
    <button id="playBtn">Play</button>

    <button id="recWebmBtn" title="Record as WebM video">Record WebM</button>
    <button id="stopSaveBtn" disabled>Stop &amp; Save</button>

    <span id="status">Idle</span>
  </div>

  <script>
    // --- Layout constants
    const CAN_W = 1000, CAN_H = 420;
    const X_START = 150, X_END = 550, X_CENTER = (X_START + X_END) / 2;
    const ROW_Y = [80, 160, 240, 320];
    const LEFT_TEXT_X = 130;
    const RIGHT_TEXT_X = 570;

    // Colours per pathway
    const PATH_COLOURS = [
      { fill: [52, 120, 246], stroke: [30, 80, 210] },   // Pathway 1 - blue
      { fill: [0, 168, 125],  stroke: [0, 120, 88] },    // Pathway 2 - green
      { fill: [242, 153, 74], stroke: [215, 112, 39] },  // Pathway 3 - orange
      { fill: [235, 87, 87],  stroke: [200, 50, 50] }    // Pathway 4 - red
    ];

    // DOM refs
    let shapeSel, speedSlider, sizeMinSlider, sizeMaxSlider, pauseBtn, playBtn, statusEl;
    let recWebmBtn, stopSaveBtn;

    // Animation state
    let paused = false;
    let t = 0;            // logical time 0..6
    let finished = false; // reached the end once (no loop)
    let explosions = [];  // particle systems
    let finishedNotified = false;

    // Recording state
    let canvasEl = null;
    let capturing = false;
    let captureMode = null;   // 'webm' | null

    // WebM recorder (MediaRecorder)
    let mediaRecorder = null;
    let webmChunks = [];

    // Custom image for Virus
    let virusImg;

    function preload() {
      virusImg = loadImage('virus.png'); // Load the saved image
    }

    function setup() {
      const cnv = createCanvas(CAN_W, CAN_H);
      pixelDensity(1); // avoid HiDPI scaling issues
      cnv.parent(document.body);
      canvasEl = cnv.canvas;
      noStroke();
      textSize(12);
      textAlign(CENTER);

      // Hook up DOM controls
      shapeSel      = document.getElementById('shapeSel');
      speedSlider   = document.getElementById('speed');
      sizeMinSlider = document.getElementById('sizeMin');
      sizeMaxSlider = document.getElementById('sizeMax');
      pauseBtn      = document.getElementById('pauseBtn');
      playBtn       = document.getElementById('playBtn');
      recWebmBtn    = document.getElementById('recWebmBtn');
      stopSaveBtn   = document.getElementById('stopSaveBtn');
      statusEl      = document.getElementById('status');

      pauseBtn.onclick = () => {
        if (finished) return;
        paused = !paused;
        pauseBtn.textContent = paused ? 'Play (pause off)' : 'Pause';
        setStatus(paused ? 'Paused' : 'Playing');
      };

      playBtn.onclick = () => playFromStart();

      recWebmBtn.onclick = () => startRecording('webm');
      stopSaveBtn.onclick = () => stopAndSaveRecording();

      setStatus('Idle');
    }

    function setStatus(msg) { statusEl.textContent = msg; }

    function playFromStart() {
      t = 0;
      paused = false;
      finished = false;
      finishedNotified = false;
      explosions = [];
      pauseBtn.textContent = 'Pause';
      setStatus('Playing');
      loop();
    }

    function startRecording(mode) {
      if (capturing) return;
      playFromStart(); // clean take from the beginning
      captureMode = mode;
      capturing = true;
      updateRecordButtons();

      if (mode === 'webm') {
        setStatus('Recording WebMâ€¦');
        const fps = 30;
        const stream = canvasEl.captureStream(fps);
        webmChunks = [];
        const opts = { mimeType: 'video/webm;codecs=vp9' };
        try {
          mediaRecorder = new MediaRecorder(stream, opts);
        } catch (e) {
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
        }
        mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size) webmChunks.push(e.data); };
        mediaRecorder.onstop = async () => {
          const blob = new Blob(webmChunks, { type: 'video/webm' });
          await saveBlobWithDialog(blob, 'webm', 'video/webm');
          setStatus('Saved WebM âœ…');
          mediaRecorder = null;
        };
        mediaRecorder.start();
      }
    }

    async function stopAndSaveRecording() {
      if (!capturing) return;
      stopSaveBtn.disabled = true;
      stopSaveBtn.textContent = 'Savingâ€¦';

      if (captureMode === 'webm' && mediaRecorder) {
        setStatus('Finalising WebMâ€¦');
        mediaRecorder.stop(); // onstop will save via dialog/fallback
        resetAfterSave();
      }
    }

    function resetAfterSave() {
      stopSaveBtn.disabled = false;
      stopSaveBtn.textContent = 'Stop & Save';
      capturing = false;
      captureMode = null;
      updateRecordButtons();
    }

    function updateRecordButtons() {
      recWebmBtn.disabled = capturing;
      stopSaveBtn.disabled = !capturing;
    }

    // Save helpers
    async function saveBlobWithDialog(blob, ext, mime) {
      const base = 'risk_pathways';
      const name = `${base}.${ext}`;
      if (window.showSaveFilePicker) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: name,
            types: [{ description: ext.toUpperCase(), accept: { [mime]: [`.${ext}`] } }]
          });
          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();
          return;
        } catch (err) {
          // user canceled or no gesture; fall back
        }
      }
      await saveBlobFallback(blob, ext, mime);
    }

    async function saveBlobFallback(blob, ext, mime) {
      const base = 'risk_pathways';
      const name = `${base}.${ext}`;
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 100);
    }

    function draw() {
      background(246);

      // Guides: the four paths
      stroke(200);
      for (let i = 0; i < ROW_Y.length; i++) {
        line(X_START, ROW_Y[i], X_END, ROW_Y[i]);
      }
      noStroke();

      // Titles
      fill(20);
      textAlign(CENTER);
      text('Pathway ', X_CENTER, ROW_Y[0] - 30);
      text('Pathway ', X_CENTER, ROW_Y[1] - 30);
      text('Pathway ', X_CENTER, ROW_Y[2] - 30);
      text('Pathway ', X_CENTER, ROW_Y[3] - 30);

      // Likelihood (left) & Impact (right)
      textAlign(RIGHT);
      text('High Likelihood', LEFT_TEXT_X, ROW_Y[0]);
      text('Low Likelihood',  LEFT_TEXT_X, ROW_Y[1]);
      text('Low Likelihood',  LEFT_TEXT_X, ROW_Y[2]);
      text('High Likelihood', LEFT_TEXT_X, ROW_Y[3]);

      textAlign(LEFT);
      text('Low Impact',  RIGHT_TEXT_X, ROW_Y[0]);
      text('Low Impact',  RIGHT_TEXT_X, ROW_Y[1]);
      text('High Impact', RIGHT_TEXT_X, ROW_Y[2]);
      text('High Impact', RIGHT_TEXT_X, ROW_Y[3]);

      // --- Animation timing (no loop: stop at t=6)
      const speedDiv = Number(speedSlider.value); // larger = slower
      if (!paused && !finished) {
        t += (1 / speedDiv) * 3;
        if (t >= 6) {
          t = 6;
          finished = true;
          spawnExplosion(X_END, ROW_Y[2], PATH_COLOURS[2]);
          spawnExplosion(X_END, ROW_Y[3], PATH_COLOURS[3]);
          if (!capturing) setStatus('Finished');
        }
      }

      // Sizes from UI
      const S_MIN = Number(sizeMinSlider.value);
      const S_MAX = Number(sizeMaxSlider.value);

      // Position along path
      let xPos = (t <= 3) ? X_START : map(t, 3, 6, X_START, X_END);

      // Likelihood-driven sizes
      const p1Size = (t <= 3) ? S_MAX : map(t, 3, 6, S_MAX, S_MIN); // bigâ†’small
      const p2Size = S_MIN;                                         // small constant
      const p3Size = (t <= 3) ? S_MIN : map(t, 3, 6, S_MIN, S_MAX); // smallâ†’big
      const p4Size = S_MAX;                                         // big constant

      // Markers
      setColours(0); drawMarker(shapeSel.value, xPos, ROW_Y[0], p1Size);
      setColours(1); drawMarker(shapeSel.value, xPos, ROW_Y[1], p2Size);
      setColours(2); drawMarker(shapeSel.value, xPos, ROW_Y[2], p3Size);
      setColours(3); drawMarker(shapeSel.value, xPos, ROW_Y[3], p4Size);

      // Final state
      if (finished) {
        setColours(0); drawMarker(shapeSel.value, X_END, ROW_Y[0], S_MIN);
        setColours(1); drawMarker(shapeSel.value, X_END, ROW_Y[1], S_MIN);
        setColours(2); drawMarker(shapeSel.value, X_END, ROW_Y[2], S_MAX);
        setColours(3); drawMarker(shapeSel.value, X_END, ROW_Y[3], S_MAX);
      }

      // Explosions
      updateExplosions();

      // Notify when finished
      if (finished && explosions.length === 0 && !finishedNotified) {
        finishedNotified = true;
        if (capturing) {
          setStatus('Recording complete. Click "Stop & Save" to save.');
        } else {
          noLoop();
          setStatus('Finished');
        }
      }
    }

    function setColours(i) {
      const c = PATH_COLOURS[i];
      fill(c.fill[0], c.fill[1], c.fill[2]);
      stroke(c.stroke[0], c.stroke[1], c.stroke[2]);
      strokeWeight(1.5);
    }

    function drawMarker(type, x, y, s) {
      push();
      switch (type) {
        case 'Bug':
          noStroke();
          textAlign(CENTER, CENTER);
          textSize(s * 1.2);
          text('ðŸª°', x, y + s * 0.05);
          break;
        case 'Virus':
          // Use the loaded image instead of drawing
          image(virusImg, x - s / 2, y - s / 2, s, s);
          break;
        case 'Spore':
          ellipse(x, y, s, s);
          noStroke();
          fill(255, 255, 255, 100);
          ellipse(x, y, s * 0.35, s * 0.35);
          break;
      }
      pop();
    }

    function spawnExplosion(x, y, colour) {
      const parts = [];
      const N = 60;
      for (let i = 0; i < N; i++) {
        const ang = random(TWO_PI);
        const spd = random(1.5, 4.5);
        parts.push({
          x, y,
          vx: cos(ang) * spd,
          vy: sin(ang) * spd,
          life: 0,
          maxLife: random(40, 70),
          col: colour
        });
      }
      explosions.push(parts);
    }

    function updateExplosions() {
      for (let g = explosions.length - 1; g >= 0; g--) {
        const parts = explosions[g];
        let alive = 0;
        for (let p of parts) {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.05;
          p.life++;
          const alpha = map(p.life, 0, p.maxLife, 255, 0);
          if (alpha > 0) {
            stroke(p.col.stroke[0], p.col.stroke[1], p.col.stroke[2], alpha);
            fill(p.col.fill[0], p.col.fill[1], p.col.fill[2], alpha);
            circle(p.x, p.y, 4);
            alive++;
          }
        }
        if (alive === 0) explosions.splice(g, 1);
      }
    }

    // Click canvas to quick toggle pause (while running)
    function mousePressed() {
      if (!finished && mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
        paused = !paused;
        pauseBtn.textContent = paused ? 'Play (pause off)' : 'Pause';
        setStatus(paused ? 'Paused' : 'Playing');
      }
    }
  </script>
</body>
</html>

